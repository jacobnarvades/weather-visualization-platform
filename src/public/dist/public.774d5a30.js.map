{"mappings":"ACAA,SAAS,gBAAgB,CAAC,mBAAoB,WAE1C,IAAM,EAAM,SAAS,cAAc,CAAC,YAEpC,CAAA,EAAI,MAAM,CAAG,WAET,IAAM,EAAS,SAAS,aAAa,CAAC,UAChC,EAAM,EAAO,UAAU,CAAC,KAM9B,CAAA,EAAO,KAAK,CAAG,EAAI,YAAY,CAC/B,EAAO,MAAM,CAAG,EAAI,aAAa,CAGjC,EAAI,SAAS,CAAC,EAAK,EAAG,GAItB,IAAM,EAAO,AADK,EAAI,YAAY,CAAC,EAAG,EAAG,EAAO,KAAK,CAAE,EAAO,MAAM,EAC7C,IAAI,CAGrB,EAAqB,EAAI,eAAe,CAAC,EAAO,KAAK,CAAE,EAAO,MAAM,EACpE,EAAgB,EAAmB,IAAI,CAG7C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,GAlBjB,EAmBd,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,KAAK,CAAE,GAnBpB,EAmBoC,CAE9C,IAAM,EAAU,KAAK,GAAG,CAAC,EAAI,KAAK,KAAK,CAAC,KAAgB,EAAO,KAAK,CAAG,GAEjE,EAAc,AAAC,CAAA,AADL,KAAK,GAAG,CAAC,EAAI,KAAK,KAAK,CAAC,KAAgB,EAAO,MAAM,CAAG,GACzC,EAAO,KAAK,CAAG,CAAA,EAAW,EAGnD,EAAI,CAAI,CAAC,EAAY,CACrB,EAAI,CAAI,CAAC,EAAc,EAAE,CACzB,EAAI,CAAI,CAAC,EAAc,EAAE,CACzB,EAAI,CAAI,CAAC,EAAc,EAAE,CAMzB,EAAa,AAAC,CAAA,EAAI,EAAI,CAAA,EAAK,EAC3B,EAAY,EAFA,IAEiB,EAAa,IAGhD,IAAK,IAAI,EAAK,EAAG,EAvCP,GAuCyB,EAAI,EAAK,EAAO,MAAM,CAAE,IACvD,IAAK,IAAI,EAAK,EAAG,EAxCX,GAwC6B,EAAI,EAAK,EAAO,KAAK,CAAE,IAAM,CAC5D,IAAM,EAAQ,AAAC,CAAA,AAAC,CAAA,EAAI,CAAA,EAAM,EAAO,KAAK,CAAI,CAAA,EAAI,CAAA,CAAC,EAAM,EAEjD,GAEA,CAAa,CAAC,EAAM,CAAG,EACvB,CAAa,CAAC,EAAQ,EAAE,CAAG,EAC3B,CAAa,CAAC,EAAQ,EAAE,CAAG,EAC3B,CAAa,CAAC,EAAQ,EAAE,CAAG,MAG3B,CAAa,CAAC,EAAM,CAAG,EACvB,CAAa,CAAC,EAAQ,EAAE,CAAG,EAC3B,CAAa,CAAC,EAAQ,EAAE,CAAG,EAC3B,CAAa,CAAC,EAAQ,EAAE,CAAG,EAEnC,CAER,CAIJ,EAAI,YAAY,CAAC,EAAoB,EAAG,GAGxC,IAAM,EAAiB,IAAI,KAC3B,CAAA,EAAe,GAAG,CAAG,EAAO,SAAS,GACrC,EAAe,EAAE,CAAG,YACpB,EAAe,GAAG,CAAG,kBACrB,EAAe,SAAS,CAAC,GAAG,CAAC,aAG7B,EAAI,UAAU,CAAC,YAAY,CAAC,EAAgB,GAG5C,IAAM,EAAQ,SAAS,aAAa,CAAC,QACrC,CAAA,EAAM,WAAW,CAAG;A;A;A;A;A;AAMpB,QAAA,CAAC,CACD,SAAS,IAAI,CAAC,WAAW,CAAC,EAC9B,EAGI,EAAI,QAAQ,EACZ,EAAI,MAAM,EAElB","sources":["<anon>","src/public/js/8-bit.js"],"sourcesContent":["document.addEventListener('DOMContentLoaded', function() {\n    // Wait for the SVG to load completely\n    const img = document.getElementById('world-map');\n    img.onload = function() {\n        // Create a canvas element to work with the SVG\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        // Set pixel size (larger = more pixelated)\n        const pixelSize = 7;\n        // Set canvas dimensions\n        canvas.width = img.naturalWidth;\n        canvas.height = img.naturalHeight;\n        // Draw the original image to the canvas\n        ctx.drawImage(img, 0, 0);\n        // Get image data\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const data = imageData.data;\n        // Create pixelated version\n        const pixelatedImageData = ctx.createImageData(canvas.width, canvas.height);\n        const pixelatedData = pixelatedImageData.data;\n        // Process the image data to create 8-bit effect\n        for(let y = 0; y < canvas.height; y += pixelSize)for(let x = 0; x < canvas.width; x += pixelSize){\n            // Sample the color from the center of each pixel block\n            const sampleX = Math.min(x + Math.floor(pixelSize / 2), canvas.width - 1);\n            const sampleY = Math.min(y + Math.floor(pixelSize / 2), canvas.height - 1);\n            const sampleIndex = (sampleY * canvas.width + sampleX) * 4;\n            // Get the color from the sample point\n            const r = data[sampleIndex];\n            const g = data[sampleIndex + 1];\n            const b = data[sampleIndex + 2];\n            const a = data[sampleIndex + 3];\n            // Determine if this pixel should be colored or transparent\n            // We'll consider a pixel visible if its alpha is above a threshold\n            // or if it has significant color (not white/transparent)\n            const threshold = 50; // Adjust this threshold as needed\n            const brightness = (r + g + b) / 3;\n            const isVisible = a > threshold && brightness < 240; // Assuming white/light colors are background\n            // Fill the entire pixel block with this color or make it transparent\n            for(let py = 0; py < pixelSize && y + py < canvas.height; py++)for(let px = 0; px < pixelSize && x + px < canvas.width; px++){\n                const index = ((y + py) * canvas.width + (x + px)) * 4;\n                if (isVisible) {\n                    // Use the original color but fully opaque\n                    pixelatedData[index] = r;\n                    pixelatedData[index + 1] = g;\n                    pixelatedData[index + 2] = b;\n                    pixelatedData[index + 3] = 255; // Fully opaque\n                } else {\n                    // Make it transparent\n                    pixelatedData[index] = 0;\n                    pixelatedData[index + 1] = 0;\n                    pixelatedData[index + 2] = 0;\n                    pixelatedData[index + 3] = 0; // Fully transparent\n                }\n            }\n        }\n        // Put the pixelated image data back to the canvas\n        ctx.putImageData(pixelatedImageData, 0, 0);\n        // Create a new image element with the pixelated data\n        const pixelatedImage = new Image();\n        pixelatedImage.src = canvas.toDataURL();\n        pixelatedImage.id = 'world-map';\n        pixelatedImage.alt = '8-bit world map';\n        pixelatedImage.classList.add('pixelated');\n        // Replace the original image with the pixelated one\n        img.parentNode.replaceChild(pixelatedImage, img);\n        // Add a style to ensure the image displays with crisp pixels\n        const style = document.createElement('style');\n        style.textContent = `\n            .pixelated {\n                image-rendering: pixelated;\n                image-rendering: -moz-crisp-edges;\n                image-rendering: crisp-edges;\n            }\n        `;\n        document.head.appendChild(style);\n    };\n    // If the image is already loaded, manually trigger the onload event\n    if (img.complete) img.onload();\n});\n\n//# sourceMappingURL=public.774d5a30.js.map\n","document.addEventListener('DOMContentLoaded', function() {\n    // Wait for the SVG to load completely\n    const img = document.getElementById('world-map');\n    \n    img.onload = function() {\n        // Create a canvas element to work with the SVG\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        // Set pixel size (larger = more pixelated)\n        const pixelSize = 7;\n        \n        // Set canvas dimensions\n        canvas.width = img.naturalWidth;\n        canvas.height = img.naturalHeight;\n        \n        // Draw the original image to the canvas\n        ctx.drawImage(img, 0, 0);\n        \n        // Get image data\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const data = imageData.data;\n        \n        // Create pixelated version\n        const pixelatedImageData = ctx.createImageData(canvas.width, canvas.height);\n        const pixelatedData = pixelatedImageData.data;\n        \n        // Process the image data to create 8-bit effect\n        for (let y = 0; y < canvas.height; y += pixelSize) {\n            for (let x = 0; x < canvas.width; x += pixelSize) {\n                // Sample the color from the center of each pixel block\n                const sampleX = Math.min(x + Math.floor(pixelSize / 2), canvas.width - 1);\n                const sampleY = Math.min(y + Math.floor(pixelSize / 2), canvas.height - 1);\n                const sampleIndex = (sampleY * canvas.width + sampleX) * 4;\n                \n                // Get the color from the sample point\n                const r = data[sampleIndex];\n                const g = data[sampleIndex + 1];\n                const b = data[sampleIndex + 2];\n                const a = data[sampleIndex + 3];\n                \n                // Determine if this pixel should be colored or transparent\n                // We'll consider a pixel visible if its alpha is above a threshold\n                // or if it has significant color (not white/transparent)\n                const threshold = 50; // Adjust this threshold as needed\n                const brightness = (r + g + b) / 3;\n                const isVisible = a > threshold && brightness < 240; // Assuming white/light colors are background\n                \n                // Fill the entire pixel block with this color or make it transparent\n                for (let py = 0; py < pixelSize && y + py < canvas.height; py++) {\n                    for (let px = 0; px < pixelSize && x + px < canvas.width; px++) {\n                        const index = ((y + py) * canvas.width + (x + px)) * 4;\n                        \n                        if (isVisible) {\n                            // Use the original color but fully opaque\n                            pixelatedData[index] = r;\n                            pixelatedData[index + 1] = g;\n                            pixelatedData[index + 2] = b;\n                            pixelatedData[index + 3] = 255; // Fully opaque\n                        } else {\n                            // Make it transparent\n                            pixelatedData[index] = 0;\n                            pixelatedData[index + 1] = 0;\n                            pixelatedData[index + 2] = 0;\n                            pixelatedData[index + 3] = 0; // Fully transparent\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Put the pixelated image data back to the canvas\n        ctx.putImageData(pixelatedImageData, 0, 0);\n        \n        // Create a new image element with the pixelated data\n        const pixelatedImage = new Image();\n        pixelatedImage.src = canvas.toDataURL();\n        pixelatedImage.id = 'world-map';\n        pixelatedImage.alt = '8-bit world map';\n        pixelatedImage.classList.add('pixelated');\n        \n        // Replace the original image with the pixelated one\n        img.parentNode.replaceChild(pixelatedImage, img);\n        \n        // Add a style to ensure the image displays with crisp pixels\n        const style = document.createElement('style');\n        style.textContent = `\n            .pixelated {\n                image-rendering: pixelated;\n                image-rendering: -moz-crisp-edges;\n                image-rendering: crisp-edges;\n            }\n        `;\n        document.head.appendChild(style);\n    };\n    \n    // If the image is already loaded, manually trigger the onload event\n    if (img.complete) {\n        img.onload();\n    }\n});\n"],"names":["document","addEventListener","img","getElementById","onload","canvas","createElement","ctx","getContext","width","naturalWidth","height","naturalHeight","drawImage","data","imageData","getImageData","pixelatedImageData","createImageData","pixelatedData","y","x","sampleX","Math","min","floor","pixelSize","sampleIndex","sampleY","r","g","b","a","brightness","isVisible","py","px","index","putImageData","pixelatedImage","Image","src","toDataURL","id","alt","classList","add","parentNode","replaceChild","style","textContent","head","appendChild","complete"],"version":3,"file":"public.774d5a30.js.map"}